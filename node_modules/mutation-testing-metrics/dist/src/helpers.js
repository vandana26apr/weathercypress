"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const SEPARATOR = '/';
function flatMap(source, fn) {
    const result = [];
    source.map(fn).forEach(items => result.push(...items));
    return result;
}
exports.flatMap = flatMap;
function pathJoin(...parts) {
    return parts.reduce((prev, current) => prev.length ? current ? `${prev}/${current}` : prev : current, '');
}
exports.pathJoin = pathJoin;
function normalizeFileNames(input) {
    const fileNames = Object.keys(input);
    const commonBasePath = determineCommonBasePath(fileNames);
    const output = {};
    fileNames.forEach(fileName => {
        output[normalize(fileName.substr(commonBasePath.length))] = input[fileName];
    });
    return output;
}
exports.normalizeFileNames = normalizeFileNames;
function normalize(fileName) {
    return fileName.split(/\/|\\/)
        .filter(pathPart => pathPart)
        .join('/');
}
function determineCommonBasePath(fileNames) {
    const directories = fileNames.map(fileName => fileName.split(/\/|\\/).slice(0, -1));
    if (fileNames.length) {
        return directories.reduce(filterDirectories).join(SEPARATOR);
    }
    else {
        return '';
    }
    function filterDirectories(previousDirectories, currentDirectories) {
        for (let i = 0; i < previousDirectories.length; i++) {
            if (previousDirectories[i] !== currentDirectories[i]) {
                return previousDirectories.splice(0, i);
            }
        }
        return previousDirectories;
    }
}
function compareNames(a, b) {
    const sortValue = (metricsResult) => {
        // Directories first
        if (metricsResult.file) {
            return `1${metricsResult.name}`;
        }
        else {
            return `0${metricsResult.name}`;
        }
    };
    return sortValue(a).localeCompare(sortValue(b));
}
exports.compareNames = compareNames;
//# sourceMappingURL=helpers.js.map