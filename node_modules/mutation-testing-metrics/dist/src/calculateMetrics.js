"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
const lodash_groupby_1 = __importDefault(require("lodash.groupby"));
const DEFAULT_SCORE = 100;
const ROOT_NAME = 'All files';
/**
 * Calculates the metrics inside of a mutation testing report
 * @param files The files inside the mutation testing report
 * @returns A MetricsResult containing the metrics for the entire report. See `childResults`
 */
function calculateMetrics(files) {
    const normalizedFiles = helpers_1.normalizeFileNames(files);
    return calculateDirectoryMetrics(normalizedFiles, ROOT_NAME);
}
exports.calculateMetrics = calculateMetrics;
function calculateDirectoryMetrics(files, name) {
    const metrics = countMetrics(helpers_1.flatMap(Object.values(files), file => file.mutants));
    const childResults = toChildModels(files);
    return {
        name,
        childResults,
        metrics
    };
}
function calculateFileMetrics(fileName, file) {
    return {
        file,
        name: fileName,
        childResults: [],
        metrics: countMetrics(file.mutants)
    };
}
function toChildModels(files) {
    const filesByDirectory = lodash_groupby_1.default(Object.entries(files), namedFile => namedFile[0].split('/')[0]);
    return Object.keys(filesByDirectory)
        .map(directoryName => {
        if (filesByDirectory[directoryName].length > 1 || filesByDirectory[directoryName][0][0] !== directoryName) {
            const directoryFiles = {};
            filesByDirectory[directoryName].forEach(file => directoryFiles[file[0].substr(directoryName.length + 1)] = file[1]);
            return calculateDirectoryMetrics(directoryFiles, directoryName);
        }
        else {
            const fileName = filesByDirectory[directoryName][0][0];
            const file = filesByDirectory[directoryName][0][1];
            return calculateFileMetrics(fileName, file);
        }
    })
        .sort(helpers_1.compareNames);
}
function countMetrics(mutants) {
    const count = (status) => mutants.filter(_ => _.status === status).length;
    const killed = count("Killed" /* Killed */);
    const timeout = count("Timeout" /* Timeout */);
    const survived = count("Survived" /* Survived */);
    const noCoverage = count("NoCoverage" /* NoCoverage */);
    const runtimeErrors = count("RuntimeError" /* RuntimeError */);
    const compileErrors = count("CompileError" /* CompileError */);
    const totalDetected = timeout + killed;
    const totalUndetected = survived + noCoverage;
    const totalCovered = totalDetected + survived;
    const totalValid = totalUndetected + totalDetected;
    const totalInvalid = runtimeErrors + compileErrors;
    return {
        killed,
        timeout,
        survived,
        noCoverage,
        runtimeErrors,
        compileErrors,
        totalDetected,
        totalUndetected, totalCovered,
        totalValid,
        totalInvalid,
        mutationScore: totalValid > 0 ? totalDetected / totalValid * 100 : DEFAULT_SCORE,
        totalMutants: totalValid + totalInvalid,
        mutationScoreBasedOnCoveredCode: totalValid > 0 ? totalDetected / totalCovered * 100 || 0 : DEFAULT_SCORE
    };
}
//# sourceMappingURL=calculateMetrics.js.map