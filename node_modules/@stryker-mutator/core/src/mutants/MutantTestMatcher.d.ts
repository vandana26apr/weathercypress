import { StrykerOptions } from '@stryker-mutator/api/core';
import { Logger } from '@stryker-mutator/api/logging';
import { Mutant } from '@stryker-mutator/api/mutant';
import InputFileCollection from '../input/InputFileCollection';
import { InitialTestRunResult } from '../process/InitialTestExecutor';
import StrictReporter from '../reporters/StrictReporter';
import TestableMutant from '../TestableMutant';
export declare class MutantTestMatcher {
    private readonly log;
    private readonly options;
    private readonly reporter;
    private readonly input;
    private readonly initialRunResult;
    static inject: ["logger", "options", "reporter", "inputFiles", "initialRunResult"];
    constructor(log: Logger, options: StrykerOptions, reporter: StrictReporter, input: InputFileCollection, initialRunResult: InitialTestRunResult);
    private get baseline();
    matchWithMutants(mutants: readonly Mutant[]): Promise<readonly TestableMutant[]>;
    enrichWithCoveredTests(testableMutant: TestableMutant): Promise<void>;
    private isCoveredByBaseline;
    private isCoveredByTest;
    private isCoveredByCoverageCollection;
    private createTestableMutants;
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param testableMutant The mutant.
     * @returns The MatchedMutant
     */
    private mapMutantOnMatchedMutant;
    private findMatchingStatement;
    /**
     * Finds the smallest statement that covers a location
     * @param needle The location to find.
     * @param haystack the statement map or function map to search in.
     * @returns The index of the smallest statement surrounding the location, or null if not found.
     */
    private findMatchingStatementInMap;
    private findCoverageCollectionForTest;
    private isCoveragePerTestResult;
}
//# sourceMappingURL=MutantTestMatcher.d.ts.map