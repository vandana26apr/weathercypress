"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_1 = require("@stryker-mutator/api/plugin");
const di_1 = require("../di");
const SourceFile_1 = require("../SourceFile");
const TestableMutant_1 = require("../TestableMutant");
const LocationHelper_1 = require("../utils/LocationHelper");
const objectUtils_1 = require("../utils/objectUtils");
class MutantTestMatcher {
    constructor(log, options, reporter, input, initialRunResult) {
        this.log = log;
        this.options = options;
        this.reporter = reporter;
        this.input = input;
        this.initialRunResult = initialRunResult;
    }
    get baseline() {
        if (this.isCoveragePerTestResult(this.initialRunResult.runResult.coverage)) {
            return this.initialRunResult.runResult.coverage.baseline;
        }
        else {
            return null;
        }
    }
    async matchWithMutants(mutants) {
        const testableMutants = this.createTestableMutants(mutants);
        if (this.options.coverageAnalysis === 'off') {
            testableMutants.forEach(mutant => mutant.selectAllTests(this.initialRunResult.runResult, TestableMutant_1.TestSelectionResult.Success));
        }
        else if (!this.initialRunResult.runResult.coverage) {
            this.log.warn('No coverage result found, even though coverageAnalysis is "%s". Assuming that all tests cover each mutant. This might have a big impact on the performance.', this.options.coverageAnalysis);
            testableMutants.forEach(mutant => mutant.selectAllTests(this.initialRunResult.runResult, TestableMutant_1.TestSelectionResult.FailedButAlreadyReported));
        }
        else {
            await Promise.all(testableMutants.map(testableMutant => this.enrichWithCoveredTests(testableMutant)));
        }
        this.reporter.onAllMutantsMatchedWithTests(Object.freeze(testableMutants.map(this.mapMutantOnMatchedMutant)));
        return testableMutants;
    }
    async enrichWithCoveredTests(testableMutant) {
        const transpiledLocation = await this.initialRunResult.sourceMapper.transpiledLocationFor({
            fileName: testableMutant.mutant.fileName,
            location: testableMutant.location
        });
        const fileCoverage = this.initialRunResult.coverageMaps[transpiledLocation.fileName];
        const statementIndex = this.findMatchingStatement(new LocationHelper_1.default(transpiledLocation.location), fileCoverage);
        if (statementIndex) {
            if (this.isCoveredByBaseline(transpiledLocation.fileName, statementIndex)) {
                testableMutant.selectAllTests(this.initialRunResult.runResult, TestableMutant_1.TestSelectionResult.Success);
            }
            else {
                this.initialRunResult.runResult.tests.forEach((testResult, id) => {
                    if (this.isCoveredByTest(id, transpiledLocation.fileName, statementIndex)) {
                        testableMutant.selectTest(testResult, id);
                    }
                });
            }
        }
        else {
            // Could not find a statement corresponding to this mutant
            // This can happen when for example mutating a TypeScript interface
            // It should result in an early result during mutation testing
            // Lets delay error reporting for now
            testableMutant.selectAllTests(this.initialRunResult.runResult, TestableMutant_1.TestSelectionResult.Failed);
        }
    }
    isCoveredByBaseline(fileName, statementIndex) {
        if (this.baseline) {
            const coverageResult = this.baseline[fileName];
            return this.isCoveredByCoverageCollection(coverageResult, statementIndex);
        }
        else {
            return false;
        }
    }
    isCoveredByTest(testId, fileName, statementIndex) {
        const coverageCollection = this.findCoverageCollectionForTest(testId);
        const coveredFile = coverageCollection && coverageCollection[fileName];
        return this.isCoveredByCoverageCollection(coveredFile, statementIndex);
    }
    isCoveredByCoverageCollection(coveredFile, statementIndex) {
        if (coveredFile) {
            if (statementIndex.kind === 1 /* Statement */) {
                return coveredFile.s[statementIndex.index] > 0;
            }
            else {
                return coveredFile.f[statementIndex.index] > 0;
            }
        }
        else {
            return false;
        }
    }
    createTestableMutants(mutants) {
        const sourceFiles = this.input.filesToMutate.map(file => new SourceFile_1.default(file));
        return objectUtils_1.filterEmpty(mutants.map((mutant, index) => {
            const sourceFile = sourceFiles.find(file => file.name === mutant.fileName);
            if (sourceFile) {
                return new TestableMutant_1.default(index.toString(), mutant, sourceFile);
            }
            else {
                this.log.error(`Mutant "${mutant.mutatorName}${mutant.replacement}" is corrupt, because cannot find a text file with name ${mutant.fileName}. List of source files: \n\t${sourceFiles.map(s => s.name).join('\n\t')}`);
                return null;
            }
        }));
    }
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param testableMutant The mutant.
     * @returns The MatchedMutant
     */
    mapMutantOnMatchedMutant(testableMutant) {
        const matchedMutant = {
            fileName: testableMutant.mutant.fileName,
            id: testableMutant.id,
            mutatorName: testableMutant.mutant.mutatorName,
            replacement: testableMutant.mutant.replacement,
            runAllTests: testableMutant.runAllTests,
            scopedTestIds: testableMutant.selectedTests.map(testSelection => testSelection.id),
            timeSpentScopedTests: testableMutant.timeSpentScopedTests
        };
        return Object.freeze(matchedMutant);
    }
    findMatchingStatement(location, fileCoverage) {
        const statementIndex = this.findMatchingStatementInMap(location, fileCoverage.statementMap);
        if (statementIndex) {
            return {
                index: statementIndex,
                kind: 1 /* Statement */
            };
        }
        else {
            const functionIndex = this.findMatchingStatementInMap(location, fileCoverage.fnMap);
            if (functionIndex) {
                return {
                    index: functionIndex,
                    kind: 0 /* Function */
                };
            }
            else {
                return null;
            }
        }
    }
    /**
     * Finds the smallest statement that covers a location
     * @param needle The location to find.
     * @param haystack the statement map or function map to search in.
     * @returns The index of the smallest statement surrounding the location, or null if not found.
     */
    findMatchingStatementInMap(needle, haystack) {
        let smallestStatement = {
            index: null,
            location: LocationHelper_1.default.MAX_VALUE
        };
        if (haystack) {
            Object.keys(haystack).forEach(statementId => {
                const statementLocation = haystack[statementId];
                if (needle.isCoveredBy(statementLocation) && smallestStatement.location.isSmallerArea(statementLocation)) {
                    smallestStatement = {
                        index: statementId,
                        location: new LocationHelper_1.default(statementLocation)
                    };
                }
            });
        }
        return smallestStatement.index;
    }
    findCoverageCollectionForTest(testId) {
        if (this.initialRunResult.runResult.coverage) {
            if (this.isCoveragePerTestResult(this.initialRunResult.runResult.coverage)) {
                return this.initialRunResult.runResult.coverage.deviations[testId];
            }
            else {
                return this.initialRunResult.runResult.coverage;
            }
        }
        else {
            return null;
        }
    }
    isCoveragePerTestResult(_coverage) {
        return this.options.coverageAnalysis === 'perTest';
    }
}
exports.MutantTestMatcher = MutantTestMatcher;
MutantTestMatcher.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.reporter, di_1.coreTokens.inputFiles, di_1.coreTokens.initialRunResult);
//# sourceMappingURL=MutantTestMatcher.js.map