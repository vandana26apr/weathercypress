"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@stryker-mutator/api/core");
const util_1 = require("@stryker-mutator/util");
const istanbul_lib_instrument_1 = require("istanbul-lib-instrument");
const coverageHooks_1 = require("./coverageHooks");
class CoverageInstrumenterTranspiler {
    constructor(settings, filesToInstrument) {
        this.settings = settings;
        this.filesToInstrument = filesToInstrument;
        this.fileCoverageMaps = Object.create(null);
        this.instrumenter = istanbul_lib_instrument_1.createInstrumenter({ coverageVariable: this.coverageVariable, preserveComments: true });
    }
    async transpile(files) {
        return files.map(file => this.instrumentFileIfNeeded(file));
    }
    /**
     * Coverage variable *must* have the name '__coverage__'. Only that variable
     * is reported back to the TestRunner process when using one of the karma
     * test framework adapters (karma-jasmine, karma-mocha, ...).
     *
     * However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,
     * because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__
     * and after each test copy over the value of that current test to the global coverage object __coverage__
     */
    get coverageVariable() {
        switch (this.settings.coverageAnalysis) {
            case 'perTest':
                return coverageHooks_1.COVERAGE_CURRENT_TEST_VARIABLE_NAME;
            default:
                return '__coverage__';
        }
    }
    patchRanges(fileCoverage) {
        function patchRange(range) {
            // Lines from istanbul are one-based, lines in Stryker are 0-based
            range.end.line--;
            range.start.line--;
        }
        Object.keys(fileCoverage.statementMap).forEach(key => patchRange(fileCoverage.statementMap[key]));
        Object.keys(fileCoverage.branchMap).forEach(key => {
            patchRange(fileCoverage.branchMap[key].loc);
            fileCoverage.branchMap[key].locations.forEach(patchRange);
            fileCoverage.branchMap[key].line--;
        });
        Object.keys(fileCoverage.fnMap).forEach(key => {
            patchRange(fileCoverage.fnMap[key].loc);
            patchRange(fileCoverage.fnMap[key].decl);
            fileCoverage.fnMap[key].line--;
        });
        return fileCoverage;
    }
    instrumentFileIfNeeded(file) {
        if (this.settings.coverageAnalysis !== 'off' && this.filesToInstrument.some(fileName => fileName === file.name)) {
            return this.instrumentFile(file);
        }
        else {
            return file;
        }
    }
    instrumentFile(sourceFile) {
        try {
            const content = this.instrumenter.instrumentSync(sourceFile.textContent, sourceFile.name);
            const fileCoverage = this.patchRanges(this.instrumenter.lastFileCoverage());
            this.fileCoverageMaps[sourceFile.name] = this.retrieveCoverageMaps(fileCoverage);
            return new core_1.File(sourceFile.name, Buffer.from(content));
        }
        catch (error) {
            throw new util_1.StrykerError(`Could not instrument "${sourceFile.name}" for code coverage`, error);
        }
    }
    retrieveCoverageMaps(input) {
        const output = {
            fnMap: {},
            statementMap: input.statementMap
        };
        Object.keys(input.fnMap).forEach(key => (output.fnMap[key] = input.fnMap[key].loc));
        return output;
    }
}
exports.default = CoverageInstrumenterTranspiler;
//# sourceMappingURL=CoverageInstrumenterTranspiler.js.map