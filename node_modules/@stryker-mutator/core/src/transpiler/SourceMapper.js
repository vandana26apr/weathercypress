"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const core_1 = require("@stryker-mutator/api/core");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const source_map_1 = require("source-map");
const objectUtils_1 = require("../utils/objectUtils");
const SOURCE_MAP_URL_REGEX = /\/\/\s*#\s*sourceMappingURL=(.*)/g;
class SourceMapError extends util_1.StrykerError {
    constructor(message, innerError) {
        super(`${message}. Cannot analyse code coverage. Setting \`coverageAnalysis: "off"\` in your stryker.conf.js will prevent this error, but forces Stryker to run each test for each mutant.`, innerError);
        Error.captureStackTrace(this, SourceMapError);
        // TS recommendation: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, SourceMapError.prototype);
    }
}
exports.SourceMapError = SourceMapError;
/**
 * Represents an object that can calculated a transpiled location for a given original location
 * It is implemented with the [composite pattern](https://en.wikipedia.org/wiki/Composite_pattern)
 * Use the `create` method to retrieve a specific `SourceMapper` implementation
 */
class SourceMapper {
    static create(transpiledFiles, options) {
        if (options.transpilers.length && options.coverageAnalysis !== 'off') {
            return new TranspiledSourceMapper(transpiledFiles);
        }
        else {
            return new PassThroughSourceMapper();
        }
    }
}
exports.default = SourceMapper;
class TranspiledSourceMapper extends SourceMapper {
    constructor(transpiledFiles) {
        super();
        this.transpiledFiles = transpiledFiles;
        this.log = log4js_1.getLogger(SourceMapper.name);
    }
    /**
     * @inheritDoc
     */
    transpiledFileNameFor(originalFileName) {
        const sourceMap = this.getSourceMap(originalFileName);
        return sourceMap.transpiledFile.name;
    }
    /**
     * @inheritdoc
     */
    async transpiledLocationFor(originalLocation) {
        const sourceMap = this.getSourceMap(originalLocation.fileName);
        const relativeSource = this.getRelativeSource(sourceMap, originalLocation);
        const start = await sourceMap.generatedPositionFor(originalLocation.location.start, relativeSource);
        const end = await sourceMap.generatedPositionFor(originalLocation.location.end, relativeSource);
        return {
            fileName: sourceMap.transpiledFile.name,
            location: {
                end,
                start
            }
        };
    }
    getRelativeSource(from, to) {
        return path.relative(path.dirname(from.sourceMapFileName), to.fileName).replace(/\\/g, '/');
    }
    /**
     * Gets the source map for given file
     */
    getSourceMap(sourceFileName) {
        if (!this.sourceMaps) {
            this.sourceMaps = this.createSourceMaps();
        }
        const sourceMap = this.sourceMaps[path.resolve(sourceFileName)];
        if (sourceMap) {
            return sourceMap;
        }
        else {
            throw new SourceMapError(`Source map not found for "${sourceFileName}"`);
        }
    }
    /**
     * Creates all source maps for lazy loading purposes
     */
    createSourceMaps() {
        const sourceMaps = Object.create(null);
        this.transpiledFiles.forEach(transpiledFile => {
            const sourceMapFile = this.getSourceMapForFile(transpiledFile);
            if (sourceMapFile) {
                const rawSourceMap = this.getRawSourceMap(sourceMapFile);
                const sourceMap = new SourceMap(transpiledFile, sourceMapFile.name, rawSourceMap);
                rawSourceMap.sources.forEach(source => {
                    const sourceFileName = path.resolve(path.dirname(sourceMapFile.name), source);
                    sourceMaps[sourceFileName] = sourceMap;
                });
            }
        });
        return sourceMaps;
    }
    getRawSourceMap(sourceMapFile) {
        try {
            return JSON.parse(sourceMapFile.textContent);
        }
        catch (error) {
            throw new SourceMapError(`Source map file "${sourceMapFile.name}" could not be parsed as json`, error);
        }
    }
    getSourceMapForFile(transpiledFile) {
        const sourceMappingUrl = this.getSourceMapUrl(transpiledFile);
        if (sourceMappingUrl) {
            return this.getSourceMapFileFromUrl(sourceMappingUrl, transpiledFile);
        }
        else {
            return null;
        }
    }
    /**
     * Gets the source map file from a url.
     * @param sourceMapUrl The source map url. Can be a data url (data:application/json;base64,ABC...), or an actual file url
     * @param transpiledFile The transpiled file for which the data url is
     */
    getSourceMapFileFromUrl(sourceMapUrl, transpiledFile) {
        const sourceMapFile = this.isInlineUrl(sourceMapUrl)
            ? this.getInlineSourceMap(sourceMapUrl, transpiledFile)
            : this.getExternalSourceMap(sourceMapUrl, transpiledFile);
        return sourceMapFile;
    }
    isInlineUrl(sourceMapUrl) {
        return sourceMapUrl.startsWith('data:');
    }
    /**
     * Gets the source map from a data url
     */
    getInlineSourceMap(sourceMapUrl, transpiledFile) {
        const supportedDataPrefix = 'data:application/json;base64,';
        if (sourceMapUrl.startsWith(supportedDataPrefix)) {
            const content = objectUtils_1.base64Decode(sourceMapUrl.substr(supportedDataPrefix.length));
            return new core_1.File(transpiledFile.name, content);
        }
        else {
            throw new SourceMapError(`Source map file for "${transpiledFile.name}" cannot be read. Data url "${sourceMapUrl.substr(0, sourceMapUrl.lastIndexOf(','))}" found, where "${supportedDataPrefix.substr(0, supportedDataPrefix.length - 1)}" was expected`);
        }
    }
    /**
     * Gets the source map from a file
     */
    getExternalSourceMap(sourceMapUrl, transpiledFile) {
        const sourceMapFileName = path.resolve(path.dirname(transpiledFile.name), sourceMapUrl);
        const sourceMapFile = this.transpiledFiles.find(file => path.resolve(file.name) === sourceMapFileName);
        if (sourceMapFile) {
            return sourceMapFile;
        }
        else {
            throw new SourceMapError(`Source map file "${sourceMapUrl}" (referenced by "${transpiledFile.name}") cannot be found in list of transpiled files`);
        }
    }
    /**
     * Gets the source map url from a transpiled file (the last comment with sourceMappingURL= ...)
     */
    getSourceMapUrl(transpiledFile) {
        SOURCE_MAP_URL_REGEX.lastIndex = 0;
        let currentMatch;
        let lastMatch = null;
        // Retrieve the final sourceMappingURL comment in the file
        while ((currentMatch = SOURCE_MAP_URL_REGEX.exec(transpiledFile.textContent))) {
            lastMatch = currentMatch;
        }
        if (lastMatch) {
            this.log.debug('Source map url found in transpiled file "%s"', transpiledFile.name);
            return lastMatch[1];
        }
        else {
            this.log.debug('No source map url found in transpiled file "%s"', transpiledFile.name);
            return null;
        }
    }
}
exports.TranspiledSourceMapper = TranspiledSourceMapper;
class PassThroughSourceMapper extends SourceMapper {
    /**
     * @inheritdoc
     */
    transpiledFileNameFor(originalFileName) {
        return originalFileName;
    }
    /**
     * @inheritdoc
     */
    async transpiledLocationFor(originalLocation) {
        return Promise.resolve(originalLocation);
    }
}
exports.PassThroughSourceMapper = PassThroughSourceMapper;
class SourceMap {
    constructor(transpiledFile, sourceMapFileName, rawSourceMap) {
        this.transpiledFile = transpiledFile;
        this.sourceMapFileName = sourceMapFileName;
        this.rawSourceMap = rawSourceMap;
    }
    async generatedPositionFor(originalPosition, relativeSource) {
        if (!this.sourceMap) {
            this.sourceMap = await new source_map_1.SourceMapConsumer(this.rawSourceMap);
        }
        const transpiledPosition = await this.sourceMap.generatedPositionFor({
            bias: source_map_1.SourceMapConsumer.LEAST_UPPER_BOUND,
            column: originalPosition.column,
            line: originalPosition.line + 1,
            source: relativeSource
        });
        return Promise.resolve({
            column: transpiledPosition.column || 0,
            line: (transpiledPosition.line || 1) - 1 // Stryker works 0-based
        });
    }
}
//# sourceMappingURL=SourceMapper.js.map