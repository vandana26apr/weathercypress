"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const rxjs_1 = require("rxjs");
const rxjs_2 = require("rxjs");
const rxjs_3 = require("rxjs");
const operators_1 = require("rxjs/operators");
const di_1 = require("../di");
const TranspiledMutant_1 = require("../TranspiledMutant");
const INITIAL_CONCURRENCY = 100;
class MutantTranspileScheduler {
    /**
     * Creates a mutant transpiler
     */
    constructor(transpiler, unMutatedFiles) {
        this.transpiler = transpiler;
        this.unMutatedFiles = unMutatedFiles;
        this.concurrencyTicket$ = new rxjs_2.BehaviorSubject(INITIAL_CONCURRENCY);
        /**
         * Schedule next mutant to be transpiled
         */
        this.scheduleNext = () => {
            this.concurrencyTicket$.next(1);
        };
    }
    scheduleTranspileMutants(allMutants) {
        return rxjs_3.from(allMutants).pipe(operators_1.zip(this.concurrencyTicket$.pipe(operators_1.flatMap(n => rxjs_1.range(0, n)))), operators_1.flatMap(([mutant]) => this.transpileMutant(mutant), 1 /* IMPORTANT! Never transpile multiple mutants at once! */));
    }
    /**
     * Dispose
     */
    dispose() {
        this.concurrencyTicket$.complete();
    }
    createTranspiledMutant(mutant, transpileResult) {
        return new TranspiledMutant_1.default(mutant, transpileResult, someFilesChanged(this.unMutatedFiles));
        function someFilesChanged(unMutatedFiles) {
            return transpileResult.outputFiles.some(file => fileChanged(file, unMutatedFiles));
        }
        function fileChanged(file, unMutatedFiles) {
            if (unMutatedFiles) {
                const unMutatedFile = unMutatedFiles.find(f => f.name === file.name);
                return !unMutatedFile || unMutatedFile.textContent !== file.textContent;
            }
            else {
                return true;
            }
        }
    }
    async transpileMutant(mutant) {
        const filesToTranspile = [];
        if (this.currentMutatedFile && this.currentMutatedFile.name !== mutant.fileName) {
            filesToTranspile.push(this.currentMutatedFile.file);
        }
        this.currentMutatedFile = mutant.sourceFile;
        const mutatedFile = new core_1.File(mutant.fileName, Buffer.from(mutant.mutatedCode));
        filesToTranspile.push(mutatedFile);
        try {
            const transpiledFiles = await this.transpiler.transpile(filesToTranspile);
            return this.createTranspiledMutant(mutant, { outputFiles: transpiledFiles, error: null });
        }
        catch (error) {
            return this.createTranspiledMutant(mutant, { outputFiles: [], error: util_1.errorToString(error) });
        }
    }
}
exports.MutantTranspileScheduler = MutantTranspileScheduler;
MutantTranspileScheduler.inject = plugin_1.tokens(di_1.coreTokens.transpiler, di_1.coreTokens.transpiledFiles);
//# sourceMappingURL=MutantTranspileScheduler.js.map