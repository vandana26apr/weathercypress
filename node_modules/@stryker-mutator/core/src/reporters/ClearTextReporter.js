"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const plugin_1 = require("@stryker-mutator/api/plugin");
const report_1 = require("@stryker-mutator/api/report");
const mutation_testing_metrics_1 = require("mutation-testing-metrics");
const typed_inject_1 = require("typed-inject");
const chalk = require("chalk");
const ClearTextScoreTable_1 = require("./ClearTextScoreTable");
class ClearTextReporter {
    constructor(log, options) {
        this.log = log;
        this.options = options;
        this.out = process.stdout;
        this.configConsoleColor();
    }
    writeLine(output) {
        this.out.write(`${output || ''}${os.EOL}`);
    }
    configConsoleColor() {
        if (!this.options.allowConsoleColors) {
            chalk.level = 0; // All colors disabled
        }
    }
    onAllMutantsTested(mutantResults) {
        this.writeLine();
        let totalTests = 0;
        // use these fn's in order to preserve the 'this` pointer
        const logDebugFn = (input) => this.log.debug(input);
        const writeLineFn = (input) => this.writeLine(input);
        mutantResults.forEach((result, index) => {
            if (result.testsRan) {
                totalTests += result.testsRan.length;
            }
            switch (result.status) {
                case report_1.MutantStatus.Killed:
                    this.log.debug(chalk.bold.green('Mutant killed!'));
                    this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.TimedOut:
                    this.log.debug(chalk.bold.yellow('Mutant timed out!'));
                    this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.RuntimeError:
                    this.log.debug(chalk.bold.yellow('Mutant caused a runtime error!'));
                    this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.TranspileError:
                    this.log.debug(chalk.bold.yellow('Mutant caused a transpile error!'));
                    this.logMutantResult(result, index, logDebugFn);
                    break;
                case report_1.MutantStatus.Survived:
                    this.logMutantResult(result, index, writeLineFn);
                    break;
                case report_1.MutantStatus.NoCoverage:
                    this.logMutantResult(result, index, writeLineFn);
                    break;
            }
        });
        this.writeLine(`Ran ${(totalTests / mutantResults.length).toFixed(2)} tests per mutant on average.`);
    }
    logMutantResult(result, index, logImplementation) {
        logImplementation(`${index}. [${report_1.MutantStatus[result.status]}] ${result.mutatorName}`);
        logImplementation(this.colorSourceFileAndLocation(result.sourceFilePath, result.location.start));
        result.originalLines.split('\n').forEach(line => {
            logImplementation(chalk.red('-   ' + line));
        });
        result.mutatedLines.split('\n').forEach(line => {
            logImplementation(chalk.green('+   ' + line));
        });
        logImplementation('');
        if (this.options.coverageAnalysis === 'perTest') {
            this.logExecutedTests(result, logImplementation);
        }
        else if (result.testsRan && result.testsRan.length > 0) {
            logImplementation('Ran all tests for this mutant.');
        }
    }
    colorSourceFileAndLocation(sourceFilePath, position) {
        const clearTextReporterConfig = this.options.clearTextReporter;
        if (clearTextReporterConfig && clearTextReporterConfig.allowColor !== false) {
            return `${sourceFilePath}:${position.line}:${position.column}`;
        }
        return [chalk.cyan(sourceFilePath), chalk.yellow(`${position.line}`), chalk.yellow(`${position.column}`)].join(':');
    }
    logExecutedTests(result, logImplementation) {
        const clearTextReporterConfig = this.options.clearTextReporter || {};
        if (!clearTextReporterConfig.logTests) {
            return;
        }
        if (result.testsRan && result.testsRan.length > 0) {
            let testsToLog = 3;
            if (typeof clearTextReporterConfig.maxTestsToLog === 'number') {
                testsToLog = clearTextReporterConfig.maxTestsToLog;
            }
            if (testsToLog > 0) {
                logImplementation('Tests ran: ');
                for (let i = 0; i < testsToLog; i++) {
                    if (i > result.testsRan.length - 1) {
                        break;
                    }
                    logImplementation('    ' + result.testsRan[i]);
                }
                if (testsToLog < result.testsRan.length) {
                    logImplementation(`  and ${result.testsRan.length - testsToLog} more tests!`);
                }
                logImplementation('');
            }
        }
    }
    onMutationTestReportReady(report) {
        const metricsResult = mutation_testing_metrics_1.calculateMetrics(report.files);
        this.writeLine(new ClearTextScoreTable_1.default(metricsResult, this.options.thresholds).draw());
    }
}
exports.default = ClearTextReporter;
ClearTextReporter.inject = typed_inject_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options);
//# sourceMappingURL=ClearTextReporter.js.map