"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const report_1 = require("@stryker-mutator/api/report");
const Timer_1 = require("../utils/Timer");
class ProgressKeeper {
    constructor() {
        this.progress = {
            survived: 0,
            timedOut: 0,
            tested: 0,
            total: 0
        };
    }
    onAllMutantsMatchedWithTests(matchedMutants) {
        this.timer = new Timer_1.default();
        this.mutantIdsWithoutCoverage = matchedMutants.filter(m => !m.runAllTests && m.scopedTestIds.length === 0).map(m => m.id);
        this.progress.total = matchedMutants.length - this.mutantIdsWithoutCoverage.length;
    }
    onMutantTested(result) {
        if (!this.mutantIdsWithoutCoverage.some(id => result.id === id)) {
            this.progress.tested++;
        }
        if (result.status === report_1.MutantStatus.Survived) {
            this.progress.survived++;
        }
        if (result.status === report_1.MutantStatus.TimedOut) {
            this.progress.timedOut++;
        }
    }
    getElapsedTime() {
        return this.formatTime(this.timer.elapsedSeconds());
    }
    getEtc() {
        const totalSecondsLeft = Math.floor((this.timer.elapsedSeconds() / this.progress.tested) * (this.progress.total - this.progress.tested));
        if (isFinite(totalSecondsLeft) && totalSecondsLeft > 0) {
            return this.formatTime(totalSecondsLeft);
        }
        else {
            return 'n/a';
        }
    }
    formatTime(timeInSeconds) {
        const hours = Math.floor(timeInSeconds / 3600);
        const minutes = Math.floor((timeInSeconds % 3600) / 60);
        return hours > 0 // conditional time formatting
            ? `~${hours}h ${minutes}m`
            : minutes > 0
                ? `~${minutes}m`
                : '<1m';
    }
}
exports.default = ProgressKeeper;
//# sourceMappingURL=ProgressKeeper.js.map