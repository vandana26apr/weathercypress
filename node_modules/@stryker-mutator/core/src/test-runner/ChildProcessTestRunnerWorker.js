"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
class ChildProcessTestRunnerWorker {
    constructor(sandboxFileNames, { testRunner }, injector) {
        this.underlyingTestRunner = injector
            .provideValue(plugin_1.commonTokens.sandboxFileNames, sandboxFileNames)
            .injectFunction(di_1.PluginCreator.createFactory(plugin_1.PluginKind.TestRunner))
            .create(testRunner);
    }
    async init() {
        if (this.underlyingTestRunner.init) {
            await this.underlyingTestRunner.init();
        }
    }
    async dispose() {
        if (this.underlyingTestRunner.dispose) {
            await this.underlyingTestRunner.dispose();
        }
    }
    async run(options) {
        const result = await this.underlyingTestRunner.run(options);
        // If the test runner didn't report on coverage, let's try to do it ourselves.
        if (!result.coverage) {
            result.coverage = global.__coverage__;
        }
        if (result.errorMessages) {
            // errorMessages should be a string[]
            // Just in case the test runner implementer forgot to convert `Error`s to string, we will do it here
            // https://github.com/stryker-mutator/stryker/issues/141
            result.errorMessages = result.errorMessages.map(util_1.errorToString);
        }
        return result;
    }
}
exports.ChildProcessTestRunnerWorker = ChildProcessTestRunnerWorker;
ChildProcessTestRunnerWorker.inject = plugin_1.tokens(plugin_1.commonTokens.sandboxFileNames, plugin_1.commonTokens.options, plugin_1.commonTokens.injector);
//# sourceMappingURL=ChildProcessTestRunnerWorker.js.map