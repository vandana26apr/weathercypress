"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_runner_1 = require("@stryker-mutator/api/test_runner");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const OutOfMemoryError_1 = require("../child-proxy/OutOfMemoryError");
const TestRunnerDecorator_1 = require("./TestRunnerDecorator");
const ERROR_MESSAGE = 'Test runner crashed. Tried twice to restart it without any luck. Last time the error message was: ';
/**
 * Wraps a test runner and implements the retry functionality.
 */
class RetryDecorator extends TestRunnerDecorator_1.default {
    constructor() {
        super(...arguments);
        this.log = log4js_1.getLogger(RetryDecorator.name);
    }
    async run(options, attemptsLeft = 2, lastError) {
        if (attemptsLeft > 0) {
            try {
                return await this.innerRunner.run(options);
            }
            catch (error) {
                if (error instanceof OutOfMemoryError_1.default) {
                    this.log.info("Test runner process [%s] ran out of memory. You probably have a memory leak in your tests. Don't worry, Stryker will restart the process, but you might want to investigate this later, because this decreases performance.", error.pid);
                }
                await this.recover();
                return this.run(options, attemptsLeft - 1, error);
            }
        }
        else {
            await this.recover();
            return { status: test_runner_1.RunStatus.Error, errorMessages: [`${ERROR_MESSAGE}${util_1.errorToString(lastError)}`], tests: [] };
        }
    }
    async recover() {
        await this.dispose();
        this.createInnerRunner();
        return this.init();
    }
}
exports.default = RetryDecorator;
//# sourceMappingURL=RetryDecorator.js.map