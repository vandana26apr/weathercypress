import { StrykerOptions } from '@stryker-mutator/api/core';
import { OptionsContext } from '@stryker-mutator/api/plugin';
import { Disposable, InjectableClass, InjectionToken } from 'typed-inject';
import LoggingClientContext from '../logging/LoggingClientContext';
declare type Func<TS extends any[], R> = (...args: TS) => R;
declare type PromisifiedFunc<TS extends any[], R> = (...args: TS) => Promise<R>;
export declare type Promisified<T> = {
    [K in keyof T]: T[K] extends PromisifiedFunc<any, any> ? T[K] : T[K] extends Func<infer TS, infer R> ? PromisifiedFunc<TS, R> : () => Promise<T[K]>;
};
export default class ChildProcessProxy<T> implements Disposable {
    readonly proxy: Promisified<T>;
    private readonly worker;
    private readonly initTask;
    private disposeTask;
    private currentError;
    private readonly workerTasks;
    private readonly log;
    private readonly stdoutBuilder;
    private readonly stderrBuilder;
    private isDisposed;
    private constructor();
    /**
     * @description Creates a proxy where each function of the object created using the constructorFunction arg is ran inside of a child process
     */
    static create<TAdditionalContext, R, Tokens extends Array<InjectionToken<OptionsContext & TAdditionalContext>>>(requirePath: string, loggingContext: LoggingClientContext, options: StrykerOptions, additionalInjectableValues: TAdditionalContext, workingDirectory: string, InjectableClass: InjectableClass<TAdditionalContext & OptionsContext, R, Tokens>): ChildProcessProxy<R>;
    private send;
    private initProxy;
    private forward;
    private listenForMessages;
    private listenToStdoutAndStderr;
    private reportError;
    private readonly handleUnexpectedExit;
    private readonly handleError;
    private innerProcessIsCrashed;
    dispose(): Promise<void>;
    private logUnidentifiedMessage;
}
export {};
//# sourceMappingURL=ChildProcessProxy.d.ts.map