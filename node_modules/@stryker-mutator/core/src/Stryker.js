"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_1 = require("@stryker-mutator/api/plugin");
const di_1 = require("./di");
const InputFileResolver_1 = require("./input/InputFileResolver");
const LogConfigurator_1 = require("./logging/LogConfigurator");
const MutantTestMatcher_1 = require("./mutants/MutantTestMatcher");
const MutatorFacade_1 = require("./mutants/MutatorFacade");
const InitialTestExecutor_1 = require("./process/InitialTestExecutor");
const MutationTestExecutor_1 = require("./process/MutationTestExecutor");
const MutationTestReportCalculator_1 = require("./reporters/MutationTestReportCalculator");
const SandboxPool_1 = require("./SandboxPool");
const ScoreResultCalculator_1 = require("./ScoreResultCalculator");
const transpiler_1 = require("./transpiler");
const MutantTranspileScheduler_1 = require("./transpiler/MutantTranspileScheduler");
const TranspilerFacade_1 = require("./transpiler/TranspilerFacade");
class Stryker {
    /**
     * The Stryker mutation tester.
     * @constructor
     * @param {Object} [cliOptions] - Optional options.
     */
    constructor(cliOptions) {
        LogConfigurator_1.default.configureMainProcess(cliOptions.logLevel, cliOptions.fileLogLevel, cliOptions.allowConsoleColors);
        this.injector = di_1.buildMainInjector(cliOptions);
        this.log = this.injector.resolve(plugin_1.commonTokens.getLogger)(Stryker.name);
        // Log level may have changed
        LogConfigurator_1.default.configureMainProcess(this.options.logLevel, this.options.fileLogLevel, this.options.allowConsoleColors);
    }
    get reporter() {
        return this.injector.resolve(di_1.coreTokens.reporter);
    }
    get options() {
        return this.injector.resolve(plugin_1.commonTokens.options);
    }
    get timer() {
        return this.injector.resolve(di_1.coreTokens.timer);
    }
    get temporaryDirectory() {
        return this.injector.resolve(di_1.coreTokens.temporaryDirectory);
    }
    async runMutationTest() {
        const loggingContext = await LogConfigurator_1.default.configureLoggingServer(this.options.logLevel, this.options.fileLogLevel, this.options.allowConsoleColors);
        this.timer.reset();
        const inputFiles = await this.injector.injectClass(InputFileResolver_1.default).resolve();
        if (inputFiles.files.length) {
            this.temporaryDirectory.initialize();
            const inputFileInjector = this.injector.provideValue(di_1.coreTokens.loggingContext, loggingContext).provideValue(di_1.coreTokens.inputFiles, inputFiles);
            const initialTestRunProcess = inputFileInjector
                .provideValue(plugin_1.commonTokens.produceSourceMaps, this.options.coverageAnalysis !== 'off')
                .provideFactory(di_1.coreTokens.pluginCreatorTranspiler, di_1.PluginCreator.createFactory(plugin_1.PluginKind.Transpiler))
                .provideClass(di_1.coreTokens.transpiler, TranspilerFacade_1.TranspilerFacade)
                .injectClass(InitialTestExecutor_1.default);
            const initialRunResult = await initialTestRunProcess.run();
            const mutator = inputFileInjector.injectClass(MutatorFacade_1.MutatorFacade);
            const transpilerProvider = inputFileInjector
                .provideValue(di_1.coreTokens.initialRunResult, initialRunResult)
                .provideValue(plugin_1.commonTokens.produceSourceMaps, false)
                .provideFactory(di_1.coreTokens.transpiler, transpiler_1.transpilerFactory);
            const transpiler = transpilerProvider.resolve(di_1.coreTokens.transpiler);
            const transpiledFiles = await transpiler.transpile(inputFiles.files);
            const mutationTestProcessInjector = transpilerProvider
                .provideValue(di_1.coreTokens.transpiledFiles, transpiledFiles)
                .provideClass(di_1.coreTokens.mutantTranspileScheduler, MutantTranspileScheduler_1.MutantTranspileScheduler)
                .provideClass(di_1.coreTokens.sandboxPool, SandboxPool_1.SandboxPool);
            const testableMutants = await mutationTestProcessInjector
                .injectClass(MutantTestMatcher_1.MutantTestMatcher)
                .matchWithMutants(mutator.mutate(inputFiles.filesToMutate));
            try {
                if (initialRunResult.runResult.tests.length && testableMutants.length) {
                    const mutationTestExecutor = mutationTestProcessInjector.injectClass(MutationTestExecutor_1.MutationTestExecutor);
                    const mutantResults = await mutationTestExecutor.run(testableMutants);
                    await this.reportScore(mutantResults, inputFileInjector);
                    await this.logDone();
                    return mutantResults;
                }
                else {
                    this.logTraceLogLevelHint();
                }
            }
            finally {
                // `injector.dispose` calls `dispose` on all created instances
                // Namely the `SandboxPool`, `MutantTranspileScheduler` and `ChildProcessProxy` instances
                await mutationTestProcessInjector.dispose();
                await LogConfigurator_1.default.shutdown();
            }
        }
        return Promise.resolve([]);
    }
    logDone() {
        this.log.info('Done in %s.', this.timer.humanReadableElapsed());
    }
    logTraceLogLevelHint() {
        if (!this.log.isTraceEnabled()) {
            this.log.info('Trouble figuring out what went wrong? Try `npx stryker run --fileLogLevel trace --logLevel debug` to get some more info.');
        }
    }
    async reportScore(mutantResults, inputFileInjector) {
        inputFileInjector.injectClass(MutationTestReportCalculator_1.MutationTestReportCalculator).report(mutantResults);
        const calculator = this.injector.injectClass(ScoreResultCalculator_1.default);
        const score = calculator.calculate(mutantResults);
        this.reporter.onScoreCalculated(score);
        calculator.determineExitCode(score, this.options.thresholds);
        await this.reporter.wrapUp();
    }
}
exports.default = Stryker;
//# sourceMappingURL=Stryker.js.map