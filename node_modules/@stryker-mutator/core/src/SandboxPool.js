"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const plugin_1 = require("@stryker-mutator/api/plugin");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const di_1 = require("./di");
const Sandbox_1 = require("./Sandbox");
const MAX_CONCURRENT_INITIALIZING_SANDBOXES = 2;
class SandboxPool {
    constructor(log, options, testFramework, initialRunResult, initialFiles, loggingContext, tempDir) {
        this.log = log;
        this.options = options;
        this.testFramework = testFramework;
        this.initialFiles = initialFiles;
        this.loggingContext = loggingContext;
        this.tempDir = tempDir;
        this.allSandboxes = [];
        this.runInSandbox = async ([mutant, sandbox]) => {
            const result = await sandbox.runMutant(mutant);
            return { result, sandbox };
        };
        this.registerSandbox = async (promisedSandbox) => {
            this.allSandboxes.push(promisedSandbox);
            return promisedSandbox;
        };
        this.isDisposed = false;
        this.overheadTimeMS = initialRunResult.overheadTimeMS;
    }
    runMutants(mutants) {
        const recycledSandboxes = new rxjs_1.Subject();
        // Make sure sandboxes get recycled
        const sandboxes = this.startSandboxes().pipe(operators_1.merge(recycledSandboxes));
        return mutants.pipe(operators_1.zip(sandboxes), operators_1.flatMap(this.runInSandbox), operators_1.tap(({ sandbox }) => {
            recycledSandboxes.next(sandbox);
        }), operators_1.map(({ result }) => result));
    }
    startSandboxes() {
        const concurrency = this.determineConcurrency();
        return rxjs_1.range(0, concurrency).pipe(operators_1.flatMap(async (n) => {
            if (this.isDisposed) {
                return null;
            }
            else {
                return this.registerSandbox(Sandbox_1.default.create(this.options, n, this.initialFiles, this.testFramework, this.overheadTimeMS, this.loggingContext, this.tempDir));
            }
        }, MAX_CONCURRENT_INITIALIZING_SANDBOXES), operators_1.filter(sandboxOrNull => !!sandboxOrNull), operators_1.map(sandbox => sandbox));
    }
    determineConcurrency() {
        let numConcurrentRunners = os.cpus().length;
        if (this.options.transpilers.length) {
            // If transpilers are configured, one core is reserved for the compiler (for now)
            numConcurrentRunners--;
        }
        let numConcurrentRunnersSource = 'CPU count';
        if (numConcurrentRunners > this.options.maxConcurrentTestRunners && this.options.maxConcurrentTestRunners > 0) {
            numConcurrentRunners = this.options.maxConcurrentTestRunners;
            numConcurrentRunnersSource = 'maxConcurrentTestRunners config';
        }
        if (numConcurrentRunners <= 0) {
            numConcurrentRunners = 1;
        }
        this.log.info(`Creating ${numConcurrentRunners} test runners (based on ${numConcurrentRunnersSource})`);
        return numConcurrentRunners;
    }
    async dispose() {
        this.isDisposed = true;
        const sandboxes = await Promise.all(this.allSandboxes);
        await Promise.all(sandboxes.map(sandbox => sandbox.dispose()));
    }
}
exports.SandboxPool = SandboxPool;
SandboxPool.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.testFramework, di_1.coreTokens.initialRunResult, di_1.coreTokens.transpiledFiles, di_1.coreTokens.loggingContext, di_1.coreTokens.temporaryDirectory);
//# sourceMappingURL=SandboxPool.js.map