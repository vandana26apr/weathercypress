"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const plugin_1 = require("@stryker-mutator/api/plugin");
const report_1 = require("@stryker-mutator/api/report");
const flatMap = require("lodash.flatmap");
const groupBy = require("lodash.groupby");
const objectUtils_1 = require("./utils/objectUtils");
const defaultScoreIfNoValidMutants = 100;
class ScoreResultCalculator {
    constructor(log) {
        this.log = log;
    }
    calculate(results) {
        const scoreResult = this.calculateScoreResult(results, '');
        return this.wrapIfSingleFileScoreResult(scoreResult);
    }
    determineExitCode(score, thresholds) {
        const breaking = thresholds && thresholds.break;
        const formattedScore = score.mutationScore.toFixed(2);
        if (typeof breaking === 'number') {
            if (score.mutationScore < breaking) {
                this.log.error(`Final mutation score ${formattedScore} under breaking threshold ${breaking}, setting exit code to 1 (failure).`);
                this.log.info('(improve mutation score or set `thresholds.break = null` to prevent this error in the future)');
                objectUtils_1.setExitCode(1);
            }
            else {
                this.log.info(`Final mutation score of ${formattedScore} is greater than or equal to break threshold ${breaking}`);
            }
        }
        else {
            this.log.debug("No breaking threshold configured. Won't fail the build no matter how low your mutation score is. Set `thresholds.break` to change this behavior.");
        }
    }
    wrapIfSingleFileScoreResult(scoreResult) {
        if (scoreResult.representsFile) {
            return this.copy(scoreResult, {
                childResults: [this.copy(scoreResult, { name: path.basename(scoreResult.name) })],
                name: path.dirname(scoreResult.name)
            });
        }
        else {
            return scoreResult;
        }
    }
    calculateScoreResult(results, basePath) {
        const numbers = this.countNumbers(results);
        const facts = this.determineFacts(basePath, results);
        return objectUtils_1.freezeRecursively(Object.assign(numbers, facts));
    }
    copy(defaults, overrides) {
        return Object.assign({}, defaults, overrides);
    }
    determineFacts(basePath, results) {
        const name = this.determineCommonBasePath(results, basePath);
        const childResults = this.calculateChildScores(results, name, basePath);
        return {
            childResults,
            name,
            path: path.join(basePath, name),
            representsFile: childResults.length === 0 && results.length > 0
        };
    }
    compareScoreResults(a, b) {
        const sortValue = (scoreResult) => {
            // Directories first
            if (scoreResult.representsFile) {
                return `1${scoreResult.name}`;
            }
            else {
                return `0${scoreResult.name}`;
            }
        };
        return sortValue(a).localeCompare(sortValue(b));
    }
    calculateChildScores(results, parentName, basePath) {
        const childrenBasePath = parentName.length ? path.join(basePath, parentName) + path.sep : '';
        const resultsGroupedByFiles = groupBy(results, result => result.sourceFilePath.substr(childrenBasePath.length));
        const uniqueFiles = Object.keys(resultsGroupedByFiles);
        if (uniqueFiles.length > 1) {
            const filesGroupedByDirectory = groupBy(uniqueFiles, file => file.split(path.sep)[0]);
            return Object.keys(filesGroupedByDirectory)
                .map(directory => this.calculateScoreResult(flatMap(filesGroupedByDirectory[directory], file => resultsGroupedByFiles[file]), childrenBasePath))
                .sort(this.compareScoreResults);
        }
        else {
            return [];
        }
    }
    determineCommonBasePath(results, basePath) {
        const uniqueFiles = [...new Set(results.map(result => result.sourceFilePath))];
        const uniqueFileDirectories = uniqueFiles.map(file => file.substr(basePath.length).split(path.sep));
        if (uniqueFileDirectories.length) {
            return uniqueFileDirectories.reduce(this.filterDirectories).join(path.sep);
        }
        else {
            return '';
        }
    }
    filterDirectories(previousDirectories, currentDirectories) {
        for (let i = 0; i < previousDirectories.length; i++) {
            if (previousDirectories[i] !== currentDirectories[i]) {
                return previousDirectories.splice(0, i);
            }
        }
        return previousDirectories;
    }
    countNumbers(mutantResults) {
        const count = (mutantResult) => mutantResults.filter(_ => _.status === mutantResult).length;
        const killed = count(report_1.MutantStatus.Killed);
        const timedOut = count(report_1.MutantStatus.TimedOut);
        const survived = count(report_1.MutantStatus.Survived);
        const noCoverage = count(report_1.MutantStatus.NoCoverage);
        const runtimeErrors = count(report_1.MutantStatus.RuntimeError);
        const transpileErrors = count(report_1.MutantStatus.TranspileError);
        const totalDetected = timedOut + killed;
        const totalUndetected = survived + noCoverage;
        const totalCovered = totalDetected + survived;
        const totalValid = totalUndetected + totalDetected;
        const totalInvalid = runtimeErrors + transpileErrors;
        const totalMutants = totalValid + totalInvalid;
        const mutationScore = totalValid > 0 ? (totalDetected / totalValid) * 100 : defaultScoreIfNoValidMutants;
        const mutationScoreBasedOnCoveredCode = totalValid > 0 ? (totalDetected / totalCovered) * 100 || 0 : defaultScoreIfNoValidMutants;
        return {
            killed,
            mutationScore,
            mutationScoreBasedOnCoveredCode,
            noCoverage,
            runtimeErrors,
            survived,
            timedOut,
            totalCovered,
            totalDetected,
            totalInvalid,
            totalMutants,
            totalUndetected,
            totalValid,
            transpileErrors
        };
    }
}
exports.default = ScoreResultCalculator;
ScoreResultCalculator.inject = plugin_1.tokens(plugin_1.commonTokens.logger);
//# sourceMappingURL=ScoreResultCalculator.js.map