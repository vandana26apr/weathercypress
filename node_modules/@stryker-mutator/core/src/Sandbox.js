"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const report_1 = require("@stryker-mutator/api/report");
const test_runner_1 = require("@stryker-mutator/api/test_runner");
const util_1 = require("@stryker-mutator/util");
const log4js_1 = require("log4js");
const mkdirp = require("mkdirp");
const ResilientTestRunnerFactory_1 = require("./test-runner/ResilientTestRunnerFactory");
const TestableMutant_1 = require("./TestableMutant");
const fileUtils_1 = require("./utils/fileUtils");
const objectUtils_1 = require("./utils/objectUtils");
class Sandbox {
    constructor(options, index, files, testFramework, timeOverheadMS, loggingContext, temporaryDirectory) {
        this.options = options;
        this.index = index;
        this.files = files;
        this.testFramework = testFramework;
        this.timeOverheadMS = timeOverheadMS;
        this.loggingContext = loggingContext;
        this.log = log4js_1.getLogger(Sandbox.name);
        this.retrieveEarlyResult = (transpiledMutant) => {
            if (transpiledMutant.transpileResult.error) {
                if (this.log.isDebugEnabled()) {
                    this.log.debug(`Transpile error occurred: "${transpiledMutant.transpileResult.error}" during transpiling of mutant ${transpiledMutant.mutant.toString()}`);
                }
                const result = transpiledMutant.mutant.createResult(report_1.MutantStatus.TranspileError, []);
                return result;
            }
            else if (!transpiledMutant.mutant.runAllTests && !transpiledMutant.mutant.selectedTests.length) {
                const result = transpiledMutant.mutant.createResult(report_1.MutantStatus.NoCoverage, []);
                return result;
            }
            else if (!transpiledMutant.changedAnyTranspiledFiles) {
                const result = transpiledMutant.mutant.createResult(report_1.MutantStatus.Survived, []);
                return result;
            }
            else {
                // No early result possible, need to run in the sandbox later
                return null;
            }
        };
        this.workingDirectory = temporaryDirectory.createRandomDirectory('sandbox');
        this.log.debug('Creating a sandbox for files in %s', this.workingDirectory);
    }
    async initialize() {
        await this.fillSandbox();
        await this.symlinkNodeModulesIfNeeded();
        return this.initializeTestRunner();
    }
    static create(options, index, files, testFramework, timeoutOverheadMS, loggingContext, temporaryDirectory) {
        const sandbox = new Sandbox(options, index, files, testFramework, timeoutOverheadMS, loggingContext, temporaryDirectory);
        return sandbox.initialize().then(() => sandbox);
    }
    run(timeout, testHooks, mutatedFileName) {
        return this.testRunner.run({ timeout, testHooks, mutatedFileName });
    }
    dispose() {
        return this.testRunner.dispose() || Promise.resolve();
    }
    async runMutant(transpiledMutant) {
        const earlyResult = this.retrieveEarlyResult(transpiledMutant);
        if (earlyResult) {
            return earlyResult;
        }
        else {
            const mutantFiles = transpiledMutant.transpileResult.outputFiles;
            if (transpiledMutant.mutant.testSelectionResult === TestableMutant_1.TestSelectionResult.Failed) {
                this.log.warn(`Failed find coverage data for this mutant, running all tests. This might have an impact on performance: ${transpiledMutant.mutant.toString()}`);
            }
            await Promise.all(mutantFiles.map(mutatedFile => this.writeFileInSandbox(mutatedFile)));
            const runResult = await this.run(this.calculateTimeout(transpiledMutant.mutant), this.getFilterTestsHooks(transpiledMutant.mutant), this.fileMap[transpiledMutant.mutant.fileName]);
            await this.reset(mutantFiles);
            return this.collectMutantResult(transpiledMutant.mutant, runResult);
        }
    }
    collectMutantResult(mutant, runResult) {
        const status = this.determineMutantState(runResult);
        const testNames = runResult.tests.filter(t => t.status !== test_runner_1.TestStatus.Skipped).map(t => t.name);
        if (this.log.isDebugEnabled() && status === report_1.MutantStatus.RuntimeError) {
            const error = runResult.errorMessages ? runResult.errorMessages.toString() : '(undefined)';
            this.log.debug('A runtime error occurred: %s during execution of mutant: %s', error, mutant.toString());
        }
        return mutant.createResult(status, testNames);
    }
    determineMutantState(runResult) {
        switch (runResult.status) {
            case test_runner_1.RunStatus.Timeout:
                return report_1.MutantStatus.TimedOut;
            case test_runner_1.RunStatus.Error:
                return report_1.MutantStatus.RuntimeError;
            case test_runner_1.RunStatus.Complete:
                if (runResult.tests.some(t => t.status === test_runner_1.TestStatus.Failed)) {
                    return report_1.MutantStatus.Killed;
                }
                else {
                    return report_1.MutantStatus.Survived;
                }
        }
    }
    reset(mutatedFiles) {
        const originalFiles = this.files.filter(originalFile => mutatedFiles.some(mutatedFile => mutatedFile.name === originalFile.name));
        return Promise.all(originalFiles.map(file => fileUtils_1.writeFile(this.fileMap[file.name], file.content)));
    }
    writeFileInSandbox(file) {
        const fileNameInSandbox = this.fileMap[file.name];
        return fileUtils_1.writeFile(fileNameInSandbox, file.content);
    }
    fillSandbox() {
        this.fileMap = Object.create(null);
        const copyPromises = this.files.map(file => this.fillFile(file));
        return Promise.all(copyPromises);
    }
    async symlinkNodeModulesIfNeeded() {
        if (this.options.symlinkNodeModules) {
            // TODO: Change with this.options.basePath when we have it
            const basePath = process.cwd();
            const nodeModules = await fileUtils_1.findNodeModules(basePath);
            if (nodeModules) {
                await fileUtils_1.symlinkJunction(nodeModules, path.join(this.workingDirectory, 'node_modules')).catch((error) => {
                    if (error.code === 'EEXIST') {
                        this.log.warn(util_1.normalizeWhitespaces(`Could not symlink "${nodeModules}" in sandbox directory,
              it is already created in the sandbox. Please remove the node_modules from your sandbox files.
              Alternatively, set \`symlinkNodeModules\` to \`false\` to disable this warning.`));
                    }
                    else {
                        this.log.warn(`Unexpected error while trying to symlink "${nodeModules}" in sandbox directory.`, error);
                    }
                });
            }
            else {
                this.log.warn(`Could not find a node_modules folder to symlink into the sandbox directory. Search "${basePath}" and its parent directories`);
            }
        }
    }
    fillFile(file) {
        const relativePath = path.relative(process.cwd(), file.name);
        const folderName = path.join(this.workingDirectory, path.dirname(relativePath));
        mkdirp.sync(folderName);
        const targetFile = path.join(folderName, path.basename(relativePath));
        this.fileMap[file.name] = targetFile;
        return fileUtils_1.writeFile(targetFile, file.content);
    }
    async initializeTestRunner() {
        const fileNames = Object.keys(this.fileMap).map(sourceFileName => this.fileMap[sourceFileName]);
        this.log.debug('Creating test runner %s', this.index);
        this.testRunner = ResilientTestRunnerFactory_1.default.create(this.options, fileNames, this.workingDirectory, this.loggingContext);
        await this.testRunner.init();
    }
    calculateTimeout(mutant) {
        const baseTimeout = mutant.timeSpentScopedTests;
        return this.options.timeoutFactor * baseTimeout + this.options.timeoutMS + this.timeOverheadMS;
    }
    getFilterTestsHooks(mutant) {
        if (this.testFramework && !mutant.runAllTests) {
            return objectUtils_1.wrapInClosure(this.testFramework.filter(mutant.selectedTests));
        }
        else {
            return undefined;
        }
    }
}
exports.default = Sandbox;
//# sourceMappingURL=Sandbox.js.map