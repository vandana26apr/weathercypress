"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@stryker-mutator/api/core");
const plugin_1 = require("@stryker-mutator/api/plugin");
const util_1 = require("@stryker-mutator/util");
const di_1 = require("../di");
class ConfigValidator {
    constructor(log, options, testFramework) {
        this.log = log;
        this.options = options;
        this.testFramework = testFramework;
        this.isValid = true;
    }
    validate() {
        this.validateTestFramework();
        this.validateThresholds();
        this.validateMutator();
        this.validateLogLevel('logLevel');
        this.validateLogLevel('fileLogLevel');
        this.validateTimeout();
        this.validateIsNumber('maxConcurrentTestRunners', this.options.maxConcurrentTestRunners);
        this.validateIsStringArray('plugins', this.options.plugins);
        this.validateIsStringArray('reporters', this.options.reporters);
        this.validateIsStringArray('transpilers', this.options.transpilers);
        this.validateIsString('tempDirName', this.options.tempDirName);
        this.validateIsOptionalDeepString('dashboard', 'project');
        this.validateIsOptionalDeepString('dashboard', 'module');
        this.validateIsOptionalDeepString('dashboard', 'version');
        this.validateDeepEnum('dashboard', 'reportType', core_1.ALL_REPORT_TYPES);
        this.validateIsDeepString('dashboard', 'baseUrl');
        this.validateCoverageAnalysis();
        this.validateCoverageAnalysisWithRespectToTranspilers();
        this.crashIfNeeded();
    }
    validateTestFramework() {
        if (this.options.coverageAnalysis === 'perTest' && !this.testFramework) {
            this.invalidate('Configured coverage analysis "perTest" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to "all" or "off".');
        }
    }
    validateMutator() {
        const mutator = this.options.mutator;
        if (typeof mutator === 'object') {
            const mutatorDescriptor = mutator;
            this.validateIsString('mutator.name', mutatorDescriptor.name);
            this.validateIsOptionalStringArray('mutator.excludedMutations', mutatorDescriptor.excludedMutations);
            this.validateIsOptionalArray('mutator.plugins', mutatorDescriptor.plugins);
        }
        else if (typeof mutator !== 'string') {
            this.invalidate(`Value ${stringify(mutator)} is invalid for \`mutator\`. Expected either a string or an object`);
        }
    }
    validateThresholds() {
        const thresholds = this.options.thresholds;
        this.validateThresholdsValueExists('high', thresholds.high);
        this.validateThresholdsValueExists('low', thresholds.low);
        this.validateThresholdValue('high', thresholds.high);
        this.validateThresholdValue('low', thresholds.low);
        this.validateThresholdValue('break', thresholds.break);
        if (thresholds.high < thresholds.low) {
            this.invalidate(`\`thresholds.high\` is lower than \`thresholds.low\` (${thresholds.high} < ${thresholds.low})`);
        }
    }
    validateThresholdValue(name, value) {
        if (typeof value === 'number' && (value < 0 || value > 100 || isNaN(value))) {
            this.invalidate(`Value ${stringify(value)} is invalid for \`thresholds.${name}\`. Expected a number between 0 and 100`);
        }
    }
    validateThresholdsValueExists(name, value) {
        if (typeof value !== 'number') {
            this.invalidate(`Value ${stringify(value)} is invalid for \`thresholds.${name}\`. Expected a number between 0 and 100`);
        }
    }
    validateLogLevel(logProperty) {
        const logLevel = this.options[logProperty];
        const VALID_LOG_LEVEL_VALUES = [
            core_1.LogLevel.Fatal,
            core_1.LogLevel.Error,
            core_1.LogLevel.Warning,
            core_1.LogLevel.Information,
            core_1.LogLevel.Debug,
            core_1.LogLevel.Trace,
            core_1.LogLevel.Off
        ];
        if (!VALID_LOG_LEVEL_VALUES.includes(logLevel)) {
            this.invalidate(`Value "${logLevel}" is invalid for \`${logProperty}\`. Expected one of the following: ${this.joinQuotedList(VALID_LOG_LEVEL_VALUES)}`);
        }
    }
    validateTimeout() {
        this.validateIsNumber('timeoutMS', this.options.timeoutMS);
        this.validateIsNumber('timeoutFactor', this.options.timeoutFactor);
    }
    validateCoverageAnalysis() {
        const VALID_COVERAGE_ANALYSIS_VALUES = ['perTest', 'all', 'off'];
        const coverageAnalysis = this.options.coverageAnalysis;
        if (!VALID_COVERAGE_ANALYSIS_VALUES.includes(coverageAnalysis)) {
            this.invalidate(`Value ${stringify(coverageAnalysis)} is invalid for \`coverageAnalysis\`. Expected one of the following: ${this.joinQuotedList(VALID_COVERAGE_ANALYSIS_VALUES)}`);
        }
    }
    validateCoverageAnalysisWithRespectToTranspilers() {
        if (Array.isArray(this.options.transpilers) && this.options.transpilers.length > 1 && this.options.coverageAnalysis !== 'off') {
            this.invalidate(`Value "${this.options.coverageAnalysis}" for \`coverageAnalysis\` is invalid with multiple transpilers (configured transpilers: ${this.options.transpilers.join(', ')}). Please report this to the Stryker team if you whish this feature to be implemented`);
        }
    }
    crashIfNeeded() {
        if (!this.isValid) {
            throw new util_1.StrykerError('Stryker could not recover from this configuration error, see fatal log message(s) above.');
        }
    }
    validateIsNumber(fieldName, value) {
        if (typeof value !== 'number' || isNaN(value)) {
            this.invalidate(`Value ${stringify(value)} is invalid for \`${fieldName}\`. Expected a number`);
        }
    }
    validateIsString(fieldName, value) {
        if (typeof value !== 'string') {
            this.invalidate(`Value ${stringify(value)} is invalid for \`${fieldName}\`. Expected a string`);
        }
    }
    validateIsDeepString(fieldName, secondFieldName) {
        const value = this.options[fieldName][secondFieldName];
        if (typeof value !== 'string') {
            this.invalidate(`Value ${stringify(value)} is invalid for \`${fieldName}.${secondFieldName}\`. Expected a string`);
        }
    }
    validateDeepEnum(fieldName, secondFieldName, validValues) {
        const value = this.options[fieldName][secondFieldName];
        if (!validValues.includes(value)) {
            this.invalidate(`Value ${stringify(value)} is invalid for \`${fieldName}.${secondFieldName}\`. Expected one of the following: ${validValues
                .map(stringify)
                .join(', ')}`);
        }
    }
    validateIsOptionalDeepString(fieldName, secondFieldName) {
        const value = this.options[fieldName][secondFieldName];
        if (typeof value !== 'string' && value !== undefined) {
            // Let my sibling handle the error formatting
            this.validateIsDeepString(fieldName, secondFieldName);
        }
    }
    validateIsStringArray(fieldName, value) {
        if (!Array.isArray(value)) {
            this.invalidate(`Value ${stringify(value)} is invalid for \`${fieldName}\`. Expected an array`);
        }
        else {
            value.forEach(v => {
                if (typeof v !== 'string') {
                    this.invalidate(`Value ${stringify(v)} is an invalid element of \`${fieldName}\`. Expected a string`);
                }
            });
        }
    }
    validateIsArray(fieldName, value) {
        if (!Array.isArray(value)) {
            this.invalidate(`Value "${value}" is invalid for \`${fieldName}\`. Expected an array`);
        }
    }
    validateIsOptionalStringArray(fieldName, value) {
        value === undefined || this.validateIsStringArray(fieldName, value);
    }
    validateIsOptionalArray(fieldName, value) {
        value === undefined || value === null || this.validateIsArray(fieldName, value);
    }
    invalidate(message) {
        this.log.fatal(message);
        this.isValid = false;
    }
    joinQuotedList(arr) {
        return arr.map(v => `"${v}"`).join(', ');
    }
}
exports.default = ConfigValidator;
ConfigValidator.inject = plugin_1.tokens(plugin_1.commonTokens.logger, plugin_1.commonTokens.options, di_1.coreTokens.testFramework);
function stringify(value) {
    if (typeof value === 'number' && isNaN(value)) {
        return 'NaN';
    }
    else {
        return JSON.stringify(value);
    }
}
//# sourceMappingURL=ConfigValidator.js.map