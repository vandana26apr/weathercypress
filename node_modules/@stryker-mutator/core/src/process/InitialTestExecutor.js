"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const plugin_1 = require("@stryker-mutator/api/plugin");
const test_runner_1 = require("@stryker-mutator/api/test_runner");
const di_1 = require("../di");
const Sandbox_1 = require("../Sandbox");
const coverageHooks_1 = require("../transpiler/coverageHooks");
const CoverageInstrumenterTranspiler_1 = require("../transpiler/CoverageInstrumenterTranspiler");
const SourceMapper_1 = require("../transpiler/SourceMapper");
// The initial run might take a while.
// For example: angular-bootstrap takes up to 45 seconds.
// Lets take 5 minutes just to be sure
const INITIAL_RUN_TIMEOUT = 60 * 1000 * 5;
const INITIAL_TEST_RUN_MARKER = 'Initial test run';
class InitialTestExecutor {
    constructor(options, log, inputFiles, testFramework, timer, loggingContext, transpiler, tempDir) {
        this.options = options;
        this.log = log;
        this.inputFiles = inputFiles;
        this.testFramework = testFramework;
        this.timer = timer;
        this.loggingContext = loggingContext;
        this.transpiler = transpiler;
        this.tempDir = tempDir;
    }
    async run() {
        this.log.info('Starting initial test run. This may take a while.');
        // Before we can run the tests we transpile the input files.
        // Files that are not transpiled should pass through without transpiling
        const transpiledFiles = await this.transpiler.transpile(this.inputFiles.files);
        // Now that we have the transpiled files, we create a source mapper so
        // we can figure out which files we need to annotate for code coverage
        const sourceMapper = SourceMapper_1.default.create(transpiledFiles, this.options);
        // Annotate the transpiled files for code coverage. This allows the
        // test runner to report code coverage (if `coverageAnalysis` is enabled)
        const { coverageMaps, instrumentedFiles } = await this.annotateForCodeCoverage(transpiledFiles, sourceMapper);
        this.logTranspileResult(instrumentedFiles);
        const { runResult, grossTimeMS } = await this.runInSandbox(instrumentedFiles);
        const timing = this.calculateTiming(grossTimeMS, runResult.tests);
        this.validateResult(runResult, timing);
        return {
            coverageMaps,
            overheadTimeMS: timing.overhead,
            runResult,
            sourceMapper
        };
    }
    async runInSandbox(files) {
        const sandbox = await Sandbox_1.default.create(this.options, 0, files, this.testFramework, 0, this.loggingContext, this.tempDir);
        this.timer.mark(INITIAL_TEST_RUN_MARKER);
        const runResult = await sandbox.run(INITIAL_RUN_TIMEOUT, this.getCollectCoverageHooksIfNeeded());
        const grossTimeMS = this.timer.elapsedMs(INITIAL_TEST_RUN_MARKER);
        await sandbox.dispose();
        return { runResult, grossTimeMS };
    }
    async annotateForCodeCoverage(files, sourceMapper) {
        const filesToInstrument = this.inputFiles.filesToMutate.map(mutateFile => sourceMapper.transpiledFileNameFor(mutateFile.name));
        const coverageInstrumenterTranspiler = new CoverageInstrumenterTranspiler_1.default(this.options, filesToInstrument);
        const instrumentedFiles = await coverageInstrumenterTranspiler.transpile(files);
        return { coverageMaps: coverageInstrumenterTranspiler.fileCoverageMaps, instrumentedFiles };
    }
    validateResult(runResult, timing) {
        switch (runResult.status) {
            case test_runner_1.RunStatus.Complete:
                const failedTests = this.filterOutFailedTests(runResult);
                if (failedTests.length) {
                    this.logFailedTestsInInitialRun(failedTests);
                    throw new Error('There were failed tests in the initial test run.');
                }
                if (runResult.tests.length === 0) {
                    this.log.warn('No tests were executed. Stryker will exit prematurely. Please check your configuration.');
                    return;
                }
                else {
                    this.logInitialTestRunSucceeded(runResult.tests, timing);
                    return;
                }
            case test_runner_1.RunStatus.Error:
                this.logErrorsInInitialRun(runResult);
                break;
            case test_runner_1.RunStatus.Timeout:
                this.logTimeoutInitialRun(runResult);
                break;
        }
        throw new Error('Something went wrong in the initial test run');
    }
    /**
     * Calculates the timing variables for the test run.
     * grossTime = NetTime + overheadTime
     *
     * The overhead time is used to calculate exact timeout values during mutation testing.
     * See timeoutMS setting in README for more information on this calculation
     */
    calculateTiming(grossTimeMS, tests) {
        const netTimeMS = tests.reduce((total, test) => total + test.timeSpentMs, 0);
        const overheadTimeMS = grossTimeMS - netTimeMS;
        return {
            net: netTimeMS,
            overhead: overheadTimeMS < 0 ? 0 : overheadTimeMS
        };
    }
    getCollectCoverageHooksIfNeeded() {
        if (this.options.coverageAnalysis === 'perTest') {
            if (this.testFramework) {
                // Add piece of javascript to collect coverage per test results
                this.log.debug('Adding test hooks for coverageAnalysis "perTest".');
                return coverageHooks_1.coveragePerTestHooks(this.testFramework);
            }
            else {
                this.log.warn('Cannot measure coverage results per test, there is no testFramework and thus no way of executing code right before and after each test.');
            }
        }
        return undefined;
    }
    logTranspileResult(transpiledFiles) {
        if (this.options.transpilers.length && this.log.isDebugEnabled()) {
            this.log.debug(`Transpiled files: ${JSON.stringify(transpiledFiles.map(f => `${f.name}`), null, 2)}`);
        }
    }
    filterOutFailedTests(runResult) {
        return runResult.tests.filter(testResult => testResult.status === test_runner_1.TestStatus.Failed);
    }
    logInitialTestRunSucceeded(tests, timing) {
        this.log.info('Initial test run succeeded. Ran %s tests in %s (net %s ms, overhead %s ms).', tests.length, this.timer.humanReadableElapsed(), timing.net, timing.overhead);
    }
    logFailedTestsInInitialRun(failedTests) {
        let message = 'One or more tests failed in the initial test run:';
        failedTests.forEach(test => {
            message += `${os_1.EOL}\t${test.name}`;
            if (test.failureMessages && test.failureMessages.length) {
                message += `${os_1.EOL}\t\t${test.failureMessages.join(`${os_1.EOL}\t\t`)}`;
            }
        });
        this.log.error(message);
    }
    logErrorsInInitialRun(runResult) {
        let message = 'One or more tests resulted in an error:';
        if (runResult.errorMessages && runResult.errorMessages.length) {
            runResult.errorMessages.forEach(error => (message += `${os_1.EOL}\t${error}`));
        }
        this.log.error(message);
    }
    logTimeoutInitialRun(runResult) {
        let message = 'Initial test run timed out! Ran following tests before timeout:';
        runResult.tests.forEach(test => (message += `${os_1.EOL}\t${test.name} (${test_runner_1.TestStatus[test.status]})`));
        this.log.error(message);
    }
}
exports.default = InitialTestExecutor;
InitialTestExecutor.inject = plugin_1.tokens(plugin_1.commonTokens.options, plugin_1.commonTokens.logger, di_1.coreTokens.inputFiles, di_1.coreTokens.testFramework, di_1.coreTokens.timer, di_1.coreTokens.loggingContext, di_1.coreTokens.transpiler, di_1.coreTokens.temporaryDirectory);
//# sourceMappingURL=InitialTestExecutor.js.map